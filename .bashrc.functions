function parse_git_branch {
    status=`git status 2> /dev/null`
    dirty=` echo -n "${status}" 2> /dev/null | grep -q "Changed but not updated" 2> /dev/null; echo "$?"`
    untracked=`echo -n "${status}" 2> /dev/null | grep -q "Untracked files" 2> /dev/null; echo "$?"`
    ahead=` echo -n "${status}" 2> /dev/null | grep -q "Your branch is ahead of" 2> /dev/null; echo "$?"`
    newfile=` echo -n "${status}" 2> /dev/null | grep -q "new file:" 2> /dev/null; echo "$?"`
    renamed=` echo -n "${status}" 2> /dev/null | grep -q "renamed:" 2> /dev/null; echo "$?"`
    bits=''
    col='0;36'
    if [ "${dirty}" == "0" ]; then
        bits="${bits}ⅅ"
    fi
    if [ "${untracked}" == "0" ]; then
        bits="${bits}№"
    fi
    if [ "${newfile}" == "0" ]; then
        bits="${bits}ℕ"
    fi
    if [ "${ahead}" == "0" ]; then
        bits="${bits}∅"
    fi
    if [ "${renamed}" == "0" ]; then
        bits="${bits}>"
    fi
    if [ 'x' == 'x'${bits} ]; then
        col='0;32'
    fi
    color="\e[${col}m"
    git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/($(echo -e ${color})\1$(echo -e "\e[1;33m")${bits}$(echo -e "\e[0m"))/"
}

